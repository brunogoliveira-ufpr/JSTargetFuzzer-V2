

def get_operation_mapping():
    return {
        'LoadInteger': lambda output, inputs: f"const {output} = {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for LoadInteger",
        'LoadFloat': lambda output, inputs: f"const {output} = {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for LoadFloat",
        'LoadString': lambda output, inputs: f"const {output} = '{inputs[0]}';" if len(inputs) >= 1 else f"// Error: insufficient inputs for LoadString",
        'LoadBoolean': lambda output, inputs: f"const {output} = {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for LoadBoolean",
        'LoadBigInt': lambda output, inputs: f"const {output} = BigInt({inputs[0]});" if len(inputs) >= 1 else f"// Error: insufficient inputs for LoadBigInt",
        'LoadBuiltin': lambda output, inputs: f"const {output} = {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for LoadBuiltin",
        'BinaryOperation': lambda output, inputs: f"const {output} = {inputs[0]} {inputs[1]} {inputs[2]};" if len(inputs) >= 3 else f"// Error: insufficient inputs for BinaryOperation",
        'UnaryOperation': lambda output, inputs: f"const {output} = {inputs[0]} {inputs[1]};" if len(inputs) >= 2 else f"// Error: insufficient inputs for UnaryOperation",
        'CallFunction': lambda output, inputs: f"{inputs[0]}({', '.join(inputs[1:])});" if len(inputs) >= 1 else f"// Error: insufficient inputs for CallFunction",
        'CallMethod': lambda output, inputs: f"{inputs[0]}.{inputs[1]}({', '.join(inputs[2:])});" if len(inputs) >= 2 else f"// Error: insufficient inputs for CallMethod",
        'Construct': lambda output, inputs: f"new {inputs[0]}({', '.join(inputs[1:])});" if len(inputs) >= 1 else f"// Error: insufficient inputs for Construct",
        'Return': lambda output, inputs: f"return {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for Return",
        'Reassign': lambda output, inputs: f"{output} = {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for Reassign",
        'BeginFor': lambda output, inputs: f"for (let {inputs[0]} = {inputs[1]}; {inputs[0]} < {inputs[2]}; {inputs[0]} = {inputs[3]}) {{" if len(inputs) >= 4 else f"// Error: insufficient inputs for BeginFor",
        'EndFor': lambda output, inputs: f"}}",
        'LoadGlobal': lambda output, inputs: f"const {output} = {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for LoadGlobal",
        'BeginPlainFunction': lambda output, inputs: f"function {output}({', '.join(inputs)}) {{" if len(inputs) >= 1 else f"// Error: insufficient inputs for BeginPlainFunction",
        'EndPlainFunction': lambda output, inputs: f"}}",
        'BeginObjectLiteral': lambda output, inputs: f"const {output} = {{",
        'EndObjectLiteral': lambda output, inputs: f"}};",
        'ObjectLiteralAddElement': lambda output, inputs: f"{output}[{inputs[0]}] = {inputs[1]};" if len(inputs) >= 2 else f"// Error: insufficient inputs for ObjectLiteralAddElement",
        'ObjectLiteralSetPrototype': lambda output, inputs: f"Object.setPrototypeOf({output}, {inputs[0]});" if len(inputs) >= 1 else f"// Error: insufficient inputs for ObjectLiteralSetPrototype",
        'ObjectLiteralAddComputedProperty': lambda output, inputs: f"{output}[{inputs[0]}] = {inputs[1]};" if len(inputs) >= 2 else f"// Error: insufficient inputs for ObjectLiteralAddComputedProperty",
        'BeginObjectLiteralMethod': lambda output, inputs: f"{inputs[0]}({', '.join(inputs[1:])}) {{" if len(inputs) >= 1 else f"// Error: insufficient inputs for BeginObjectLiteralMethod",
        'EndObjectLiteralMethod': lambda output, inputs: f"}}",
        'BeginClassDefinition': lambda output, inputs: f"class {output} {{" if len(inputs) >= 1 else f"// Error: insufficient inputs for BeginClassDefinition",
        'EndClassDefinition': lambda output, inputs: f"}}",
        'ClassAddPrivateStaticProperty': lambda output, inputs: f"static #private {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for ClassAddPrivateStaticProperty",
        'BeginClassInstanceSetter': lambda output, inputs: f"set {inputs[0]}({inputs[1]}) {{" if len(inputs) >= 2 else f"// Error: insufficient inputs for BeginClassInstanceSetter",
        'EndClassInstanceSetter': lambda output, inputs: f"}}",
        'ClassAddInstanceProperty': lambda output, inputs: f"{output} {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for ClassAddInstanceProperty",
        'ClassAddPrivateInstanceProperty': lambda output, inputs: f"#{output} {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for ClassAddPrivateInstanceProperty",
        'ClassAddInstanceElement': lambda output, inputs: f"{output} {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for ClassAddInstanceElement",
        'ClassAddInstanceComputedProperty': lambda output, inputs: f"{output} [{inputs[0]}] = {inputs[1]};" if len(inputs) >= 2 else f"// Error: insufficient inputs for ClassAddInstanceComputedProperty",
        'BeginClassPrivateStaticMethod': lambda output, inputs: f"static #private {inputs[0]}({', '.join(inputs[1:])}) {{" if len(inputs) >= 1 else f"// Error: insufficient inputs for BeginClassPrivateStaticMethod",
        'EndClassPrivateStaticMethod': lambda output, inputs: f"}}",
        'ClassAddStaticProperty': lambda output, inputs: f"static {output} {inputs[0]};" if len(inputs) >= 1 else f"// Error: insufficient inputs for ClassAddStaticProperty",
        'BeginConstructor': lambda output, inputs: f"constructor({', '.join(inputs)}) {{" if len(inputs) >= 1 else f"// Error: insufficient inputs for BeginConstructor",
        'EndConstructor': lambda output, inputs: f"}}",
        'CreateIntArray': lambda output, inputs: f"const {output} = new Array({inputs[0]});" if len(inputs) >= 1 else f"// Error: insufficient inputs for CreateIntArray",
        'Update': lambda output, inputs: f"{inputs[0]} = {inputs[1]};" if len(inputs) >= 2 else f"// Error: insufficient inputs for Update",
        'CallComputedMethod': lambda output, inputs: f"{inputs[0]}[{inputs[1]}]({', '.join(inputs[2:])});" if len(inputs) >= 2 else f"// Error: insufficient inputs for CallComputedMethod",
    }
